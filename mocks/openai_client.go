// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"

	"github.com/radio-t/ai-podcast/podcast"
)

// OpenAIClientMock is a mock implementation of main.OpenAIClient.
//
//	func TestSomethingThatUsesOpenAIClient(t *testing.T) {
//
//		// make and configure a mocked main.OpenAIClient
//		mockedOpenAIClient := &OpenAIClientMock{
//			GenerateDiscussionFunc: func(params podcast.GenerateDiscussionParams) (podcast.Discussion, error) {
//				panic("mock out the GenerateDiscussion method")
//			},
//			GenerateSpeechFunc: func(text string, voice string) ([]byte, error) {
//				panic("mock out the GenerateSpeech method")
//			},
//		}
//
//		// use mockedOpenAIClient in code that requires main.OpenAIClient
//		// and then make assertions.
//
//	}
type OpenAIClientMock struct {
	// GenerateDiscussionFunc mocks the GenerateDiscussion method.
	GenerateDiscussionFunc func(params podcast.GenerateDiscussionParams) (podcast.Discussion, error)

	// GenerateSpeechFunc mocks the GenerateSpeech method.
	GenerateSpeechFunc func(text string, voice string) ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// GenerateDiscussion holds details about calls to the GenerateDiscussion method.
		GenerateDiscussion []struct {
			// Params is the params argument value.
			Params podcast.GenerateDiscussionParams
		}
		// GenerateSpeech holds details about calls to the GenerateSpeech method.
		GenerateSpeech []struct {
			// Text is the text argument value.
			Text string
			// Voice is the voice argument value.
			Voice string
		}
	}
	lockGenerateDiscussion sync.RWMutex
	lockGenerateSpeech     sync.RWMutex
}

// GenerateDiscussion calls GenerateDiscussionFunc.
func (mock *OpenAIClientMock) GenerateDiscussion(params podcast.GenerateDiscussionParams) (podcast.Discussion, error) {
	callInfo := struct {
		Params podcast.GenerateDiscussionParams
	}{
		Params: params,
	}
	mock.lockGenerateDiscussion.Lock()
	mock.calls.GenerateDiscussion = append(mock.calls.GenerateDiscussion, callInfo)
	mock.lockGenerateDiscussion.Unlock()
	if mock.GenerateDiscussionFunc == nil {
		var (
			discussionOut podcast.Discussion
			errOut        error
		)
		return discussionOut, errOut
	}
	return mock.GenerateDiscussionFunc(params)
}

// GenerateDiscussionCalls gets all the calls that were made to GenerateDiscussion.
// Check the length with:
//
//	len(mockedOpenAIClient.GenerateDiscussionCalls())
func (mock *OpenAIClientMock) GenerateDiscussionCalls() []struct {
	Params podcast.GenerateDiscussionParams
} {
	var calls []struct {
		Params podcast.GenerateDiscussionParams
	}
	mock.lockGenerateDiscussion.RLock()
	calls = mock.calls.GenerateDiscussion
	mock.lockGenerateDiscussion.RUnlock()
	return calls
}

// GenerateSpeech calls GenerateSpeechFunc.
func (mock *OpenAIClientMock) GenerateSpeech(text string, voice string) ([]byte, error) {
	callInfo := struct {
		Text  string
		Voice string
	}{
		Text:  text,
		Voice: voice,
	}
	mock.lockGenerateSpeech.Lock()
	mock.calls.GenerateSpeech = append(mock.calls.GenerateSpeech, callInfo)
	mock.lockGenerateSpeech.Unlock()
	if mock.GenerateSpeechFunc == nil {
		var (
			bytesOut []byte
			errOut   error
		)
		return bytesOut, errOut
	}
	return mock.GenerateSpeechFunc(text, voice)
}

// GenerateSpeechCalls gets all the calls that were made to GenerateSpeech.
// Check the length with:
//
//	len(mockedOpenAIClient.GenerateSpeechCalls())
func (mock *OpenAIClientMock) GenerateSpeechCalls() []struct {
	Text  string
	Voice string
} {
	var calls []struct {
		Text  string
		Voice string
	}
	mock.lockGenerateSpeech.RLock()
	calls = mock.calls.GenerateSpeech
	mock.lockGenerateSpeech.RUnlock()
	return calls
}
