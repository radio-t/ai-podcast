// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"

	"github.com/radio-t/ai-podcast/podcast"
)

// AudioProcessorMock is a mock implementation of main.AudioProcessor.
//
//	func TestSomethingThatUsesAudioProcessor(t *testing.T) {
//
//		// make and configure a mocked main.AudioProcessor
//		mockedAudioProcessor := &AudioProcessorMock{
//			ConcatenateFunc: func(files []string, outputFile string) error {
//				panic("mock out the Concatenate method")
//			},
//			PlayFunc: func(filename string) error {
//				panic("mock out the Play method")
//			},
//			StreamFromConcatFunc: func(concatFile string, config podcast.Config) error {
//				panic("mock out the StreamFromConcat method")
//			},
//			StreamToIcecastFunc: func(inputFile string, config podcast.Config) error {
//				panic("mock out the StreamToIcecast method")
//			},
//		}
//
//		// use mockedAudioProcessor in code that requires main.AudioProcessor
//		// and then make assertions.
//
//	}
type AudioProcessorMock struct {
	// ConcatenateFunc mocks the Concatenate method.
	ConcatenateFunc func(files []string, outputFile string) error

	// PlayFunc mocks the Play method.
	PlayFunc func(filename string) error

	// StreamFromConcatFunc mocks the StreamFromConcat method.
	StreamFromConcatFunc func(concatFile string, config podcast.Config) error

	// StreamToIcecastFunc mocks the StreamToIcecast method.
	StreamToIcecastFunc func(inputFile string, config podcast.Config) error

	// calls tracks calls to the methods.
	calls struct {
		// Concatenate holds details about calls to the Concatenate method.
		Concatenate []struct {
			// Files is the files argument value.
			Files []string
			// OutputFile is the outputFile argument value.
			OutputFile string
		}
		// Play holds details about calls to the Play method.
		Play []struct {
			// Filename is the filename argument value.
			Filename string
		}
		// StreamFromConcat holds details about calls to the StreamFromConcat method.
		StreamFromConcat []struct {
			// ConcatFile is the concatFile argument value.
			ConcatFile string
			// Config is the config argument value.
			Config podcast.Config
		}
		// StreamToIcecast holds details about calls to the StreamToIcecast method.
		StreamToIcecast []struct {
			// InputFile is the inputFile argument value.
			InputFile string
			// Config is the config argument value.
			Config podcast.Config
		}
	}
	lockConcatenate      sync.RWMutex
	lockPlay             sync.RWMutex
	lockStreamFromConcat sync.RWMutex
	lockStreamToIcecast  sync.RWMutex
}

// Concatenate calls ConcatenateFunc.
func (mock *AudioProcessorMock) Concatenate(files []string, outputFile string) error {
	callInfo := struct {
		Files      []string
		OutputFile string
	}{
		Files:      files,
		OutputFile: outputFile,
	}
	mock.lockConcatenate.Lock()
	mock.calls.Concatenate = append(mock.calls.Concatenate, callInfo)
	mock.lockConcatenate.Unlock()
	if mock.ConcatenateFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ConcatenateFunc(files, outputFile)
}

// ConcatenateCalls gets all the calls that were made to Concatenate.
// Check the length with:
//
//	len(mockedAudioProcessor.ConcatenateCalls())
func (mock *AudioProcessorMock) ConcatenateCalls() []struct {
	Files      []string
	OutputFile string
} {
	var calls []struct {
		Files      []string
		OutputFile string
	}
	mock.lockConcatenate.RLock()
	calls = mock.calls.Concatenate
	mock.lockConcatenate.RUnlock()
	return calls
}

// Play calls PlayFunc.
func (mock *AudioProcessorMock) Play(filename string) error {
	callInfo := struct {
		Filename string
	}{
		Filename: filename,
	}
	mock.lockPlay.Lock()
	mock.calls.Play = append(mock.calls.Play, callInfo)
	mock.lockPlay.Unlock()
	if mock.PlayFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PlayFunc(filename)
}

// PlayCalls gets all the calls that were made to Play.
// Check the length with:
//
//	len(mockedAudioProcessor.PlayCalls())
func (mock *AudioProcessorMock) PlayCalls() []struct {
	Filename string
} {
	var calls []struct {
		Filename string
	}
	mock.lockPlay.RLock()
	calls = mock.calls.Play
	mock.lockPlay.RUnlock()
	return calls
}

// StreamFromConcat calls StreamFromConcatFunc.
func (mock *AudioProcessorMock) StreamFromConcat(concatFile string, config podcast.Config) error {
	callInfo := struct {
		ConcatFile string
		Config     podcast.Config
	}{
		ConcatFile: concatFile,
		Config:     config,
	}
	mock.lockStreamFromConcat.Lock()
	mock.calls.StreamFromConcat = append(mock.calls.StreamFromConcat, callInfo)
	mock.lockStreamFromConcat.Unlock()
	if mock.StreamFromConcatFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.StreamFromConcatFunc(concatFile, config)
}

// StreamFromConcatCalls gets all the calls that were made to StreamFromConcat.
// Check the length with:
//
//	len(mockedAudioProcessor.StreamFromConcatCalls())
func (mock *AudioProcessorMock) StreamFromConcatCalls() []struct {
	ConcatFile string
	Config     podcast.Config
} {
	var calls []struct {
		ConcatFile string
		Config     podcast.Config
	}
	mock.lockStreamFromConcat.RLock()
	calls = mock.calls.StreamFromConcat
	mock.lockStreamFromConcat.RUnlock()
	return calls
}

// StreamToIcecast calls StreamToIcecastFunc.
func (mock *AudioProcessorMock) StreamToIcecast(inputFile string, config podcast.Config) error {
	callInfo := struct {
		InputFile string
		Config    podcast.Config
	}{
		InputFile: inputFile,
		Config:    config,
	}
	mock.lockStreamToIcecast.Lock()
	mock.calls.StreamToIcecast = append(mock.calls.StreamToIcecast, callInfo)
	mock.lockStreamToIcecast.Unlock()
	if mock.StreamToIcecastFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.StreamToIcecastFunc(inputFile, config)
}

// StreamToIcecastCalls gets all the calls that were made to StreamToIcecast.
// Check the length with:
//
//	len(mockedAudioProcessor.StreamToIcecastCalls())
func (mock *AudioProcessorMock) StreamToIcecastCalls() []struct {
	InputFile string
	Config    podcast.Config
} {
	var calls []struct {
		InputFile string
		Config    podcast.Config
	}
	mock.lockStreamToIcecast.RLock()
	calls = mock.calls.StreamToIcecast
	mock.lockStreamToIcecast.RUnlock()
	return calls
}
